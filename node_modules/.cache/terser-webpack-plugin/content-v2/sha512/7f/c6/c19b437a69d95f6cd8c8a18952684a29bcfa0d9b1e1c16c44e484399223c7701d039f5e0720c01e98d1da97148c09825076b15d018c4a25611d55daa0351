{"code":"!function(o){var e={};function i(t){if(e[t])return e[t].exports;var n=e[t]={i:t,l:!1,exports:{}};return o[t].call(n.exports,n,n.exports,i),n.l=!0,n.exports}i.m=o,i.c=e,i.d=function(o,e,t){i.o(o,e)||Object.defineProperty(o,e,{enumerable:!0,get:t})},i.r=function(o){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(o,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(o,\"__esModule\",{value:!0})},i.t=function(o,e){if(1&e&&(o=i(o)),8&e)return o;if(4&e&&\"object\"==typeof o&&o&&o.__esModule)return o;var t=Object.create(null);if(i.r(t),Object.defineProperty(t,\"default\",{enumerable:!0,value:o}),2&e&&\"string\"!=typeof o)for(var n in o)i.d(t,n,function(e){return o[e]}.bind(null,n));return t},i.n=function(o){var e=o&&o.__esModule?function(){return o.default}:function(){return o};return i.d(e,\"a\",e),e},i.o=function(o,e){return Object.prototype.hasOwnProperty.call(o,e)},i.p=\"\",i(i.s=0)}([function(o,e,i){\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0});const t=i(0);let n;const r=o=>e=>e<o?e:[...new Array(o)].map((i,t)=>r(o)(e-t-1)).reduce((o,e)=>o+e,0),c=r(3),d=r(4),s=t.robo({base:[0,1],recurrence:([o,e])=>o+e}),u=t.robo({base:[1],recurrence:([o],e)=>e*o}),a=o=>o.reduce((o,e)=>o+e,0),v=o=>t.robo({base:[...new Array(o)].map((o,e)=>e),recurrence:a}),f=v(3),B=v(4),b=t.robo({base:[0,1],next:[o=>o-2,o=>o-1],recurrence:([o,e])=>o+e}),l=t.robo({base:[0,1],next:[o=>o-1],recurrence:([o,e])=>o+e}),p=t.robo({base:[1],next:[o=>o-1],recurrence:([o],e)=>e*o}),m=t.robo({base:[1,0],recurrence:([o,e],i)=>(i-1)*(o+e)});t.robo({base:[1,0],next:[o=>o-1,o=>o-2],recurrence:([o,e],i)=>(i-1)*(o+e)});e.test=(()=>{(void 0)(\"single pass optimization works for\",function(){(void 0)(\"fibonacci\",function(){n(\"base cases\",function(){(void 0)(b(0)).toBe(0),(void 0)(b(1)).toBe(1)}),n(\"rest\",function(){(void 0)(b(2)).toBe(1),(void 0)(b(3)).toBe(2),(void 0)(b(4)).toBe(3),(void 0)(b(5)).toBe(5),(void 0)(b(6)).toBe(8)})}),(void 0)(\"implicit fibonacci\",function(){n(\"base cases\",function(){(void 0)(l(0)).toBe(0),(void 0)(l(1)).toBe(1)}),n(\"rest\",function(){(void 0)(l(2)).toBe(1),(void 0)(l(3)).toBe(2),(void 0)(l(4)).toBe(3),(void 0)(l(5)).toBe(5),(void 0)(l(6)).toBe(8)})}),(void 0)(\"super implicit fibonacci\",function(){n(\"base cases\",function(){(void 0)(s(0)).toBe(0),(void 0)(s(1)).toBe(1)}),n(\"rest\",function(){(void 0)(s(2)).toBe(1),(void 0)(s(3)).toBe(2),(void 0)(s(4)).toBe(3),(void 0)(s(5)).toBe(5),(void 0)(s(6)).toBe(8)})}),(void 0)(\"test tribonacci\",function(){n(\"base cases\",function(){(void 0)(f(0)).toBe(c(0)),(void 0)(f(1)).toBe(c(1))}),n(\"rest\",function(){(void 0)(f(2)).toBe(c(2)),(void 0)(f(3)).toBe(c(3)),(void 0)(f(4)).toBe(c(4)),(void 0)(f(5)).toBe(c(5)),(void 0)(f(6)).toBe(c(6))})}),(void 0)(\"test quadbonacci\",function(){n(\"base cases\",function(){(void 0)(B(0)).toBe(d(0)),(void 0)(B(1)).toBe(d(1))}),n(\"rest\",function(){(void 0)(B(2)).toBe(d(2)),(void 0)(B(3)).toBe(d(3)),(void 0)(B(4)).toBe(d(4)),(void 0)(B(5)).toBe(d(5)),(void 0)(B(6)).toBe(d(6))})}),(void 0)(\"factorial\",function(){n(\"base cases\",function(){(void 0)(u(0)).toBe(1)}),n(\"rest\",function(){(void 0)(u(1)).toBe(1),(void 0)(u(2)).toBe(2),(void 0)(u(3)).toBe(6),(void 0)(u(4)).toBe(24)})}),(void 0)(\"explicit factorial\",function(){n(\"base cases\",function(){(void 0)(p(0)).toBe(1)}),n(\"rest\",function(){(void 0)(p(1)).toBe(1),(void 0)(p(2)).toBe(2),(void 0)(p(3)).toBe(6),(void 0)(p(4)).toBe(24)})}),(void 0)(\"derangements\",function(){n(\"base cases\",function(){(void 0)(m(0)).toBe(1),(void 0)(m(1)).toBe(0)}),n(\"rest\",function(){(void 0)(m(2)).toBe(1),(void 0)(m(3)).toBe(2),(void 0)(m(4)).toBe(9),(void 0)(m(5)).toBe(44)})})}),(void 0)(\"single pass optimization with custom ordering works for\",function(){}),(void 0)(\"double pass optimization works for\",function(){}),(void 0)(\"double pass optimization with custom ordering works for\",function(){}),(void 0)(\"double pass time optimization works for\",function(){}),(void 0)(\"double pass time optimization with custom ordering works for\",function(){}),(void 0)(\"double pass space optimization works for\",function(){}),(void 0)(\"double pass space optimization with custom ordering works for\",function(){}),(void 0)(\"list recursion works for\",function(){}),(void 0)(\"list recursion with short circuiting works for\",function(){}),(void 0)(\"divide-and-conqceur works for\",function(){}),(void 0)(\"divide-and-conqceur implicit single-dimensional memoization works for\",function(){}),(void 0)(\"divide-and-conqceur explicit multi-dimensional memoization works for\",function(){})}),e.test()}]);","extractedComments":[]}