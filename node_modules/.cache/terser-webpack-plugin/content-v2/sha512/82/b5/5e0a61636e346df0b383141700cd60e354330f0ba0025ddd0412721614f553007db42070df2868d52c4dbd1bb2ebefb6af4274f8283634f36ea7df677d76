{"code":"!function(o){var i={};function e(t){if(i[t])return i[t].exports;var n=i[t]={i:t,l:!1,exports:{}};return o[t].call(n.exports,n,n.exports,e),n.l=!0,n.exports}e.m=o,e.c=i,e.d=function(o,i,t){e.o(o,i)||Object.defineProperty(o,i,{enumerable:!0,get:t})},e.r=function(o){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(o,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(o,\"__esModule\",{value:!0})},e.t=function(o,i){if(1&i&&(o=e(o)),8&i)return o;if(4&i&&\"object\"==typeof o&&o&&o.__esModule)return o;var t=Object.create(null);if(e.r(t),Object.defineProperty(t,\"default\",{enumerable:!0,value:o}),2&i&&\"string\"!=typeof o)for(var n in o)e.d(t,n,function(i){return o[i]}.bind(null,n));return t},e.n=function(o){var i=o&&o.__esModule?function(){return o.default}:function(){return o};return e.d(i,\"a\",i),i},e.o=function(o,i){return Object.prototype.hasOwnProperty.call(o,i)},e.p=\"\",e(e.s=1)}([function(o,i,e){var t,n;t=[e,i,e(0)],void 0===(n=function(o,i,e){\"use strict\";let t;Object.defineProperty(i,\"__esModule\",{value:!0});const n=o=>i=>i<o?i:[...new Array(o)].map((e,t)=>n(o)(i-t-1)).reduce((o,i)=>o+i,0),r=n(3),c=n(4),d=e.robo({base:[0,1],recurrence:([o,i])=>o+i}),s=e.robo({base:[1],recurrence:([o],i)=>i*o}),u=o=>o.reduce((o,i)=>o+i,0),v=o=>e.robo({base:[...new Array(o)].map((o,i)=>i),recurrence:u}),a=v(3),f=v(4),B=e.robo({base:[0,1],next:[o=>o-2,o=>o-1],recurrence:([o,i])=>o+i}),b=e.robo({base:[0,1],next:[o=>o-1],recurrence:([o,i])=>o+i}),p=e.robo({base:[1],next:[o=>o-1],recurrence:([o],i)=>i*o}),l=e.robo({base:[1,0],recurrence:([o,i],e)=>(e-1)*(o+i)});e.robo({base:[1,0],next:[o=>o-1,o=>o-2],recurrence:([o,i],e)=>(e-1)*(o+i)});i.test=(()=>{(void 0)(\"single pass optimization works for\",function(){(void 0)(\"fibonacci\",function(){t(\"base cases\",function(){(void 0)(B(0)).toBe(0),(void 0)(B(1)).toBe(1)}),t(\"rest\",function(){(void 0)(B(2)).toBe(1),(void 0)(B(3)).toBe(2),(void 0)(B(4)).toBe(3),(void 0)(B(5)).toBe(5),(void 0)(B(6)).toBe(8)})}),(void 0)(\"implicit fibonacci\",function(){t(\"base cases\",function(){(void 0)(b(0)).toBe(0),(void 0)(b(1)).toBe(1)}),t(\"rest\",function(){(void 0)(b(2)).toBe(1),(void 0)(b(3)).toBe(2),(void 0)(b(4)).toBe(3),(void 0)(b(5)).toBe(5),(void 0)(b(6)).toBe(8)})}),(void 0)(\"super implicit fibonacci\",function(){t(\"base cases\",function(){(void 0)(d(0)).toBe(0),(void 0)(d(1)).toBe(1)}),t(\"rest\",function(){(void 0)(d(2)).toBe(1),(void 0)(d(3)).toBe(2),(void 0)(d(4)).toBe(3),(void 0)(d(5)).toBe(5),(void 0)(d(6)).toBe(8)})}),(void 0)(\"test tribonacci\",function(){t(\"base cases\",function(){(void 0)(a(0)).toBe(r(0)),(void 0)(a(1)).toBe(r(1))}),t(\"rest\",function(){(void 0)(a(2)).toBe(r(2)),(void 0)(a(3)).toBe(r(3)),(void 0)(a(4)).toBe(r(4)),(void 0)(a(5)).toBe(r(5)),(void 0)(a(6)).toBe(r(6))})}),(void 0)(\"test quadbonacci\",function(){t(\"base cases\",function(){(void 0)(f(0)).toBe(c(0)),(void 0)(f(1)).toBe(c(1))}),t(\"rest\",function(){(void 0)(f(2)).toBe(c(2)),(void 0)(f(3)).toBe(c(3)),(void 0)(f(4)).toBe(c(4)),(void 0)(f(5)).toBe(c(5)),(void 0)(f(6)).toBe(c(6))})}),(void 0)(\"factorial\",function(){t(\"base cases\",function(){(void 0)(s(0)).toBe(1)}),t(\"rest\",function(){(void 0)(s(1)).toBe(1),(void 0)(s(2)).toBe(2),(void 0)(s(3)).toBe(6),(void 0)(s(4)).toBe(24)})}),(void 0)(\"explicit factorial\",function(){t(\"base cases\",function(){(void 0)(p(0)).toBe(1)}),t(\"rest\",function(){(void 0)(p(1)).toBe(1),(void 0)(p(2)).toBe(2),(void 0)(p(3)).toBe(6),(void 0)(p(4)).toBe(24)})}),(void 0)(\"derangements\",function(){t(\"base cases\",function(){(void 0)(l(0)).toBe(1),(void 0)(l(1)).toBe(0)}),t(\"rest\",function(){(void 0)(l(2)).toBe(1),(void 0)(l(3)).toBe(2),(void 0)(l(4)).toBe(9),(void 0)(l(5)).toBe(44)})})}),(void 0)(\"single pass optimization with custom ordering works for\",function(){}),(void 0)(\"double pass optimization works for\",function(){}),(void 0)(\"double pass optimization with custom ordering works for\",function(){}),(void 0)(\"double pass time optimization works for\",function(){}),(void 0)(\"double pass time optimization with custom ordering works for\",function(){}),(void 0)(\"double pass space optimization works for\",function(){}),(void 0)(\"double pass space optimization with custom ordering works for\",function(){}),(void 0)(\"list recursion works for\",function(){}),(void 0)(\"list recursion with short circuiting works for\",function(){}),(void 0)(\"divide-and-conqceur works for\",function(){}),(void 0)(\"divide-and-conqceur implicit single-dimensional memoization works for\",function(){}),(void 0)(\"divide-and-conqceur explicit multi-dimensional memoization works for\",function(){})}),i.test()}.apply(i,t))||(o.exports=n)},function(o,i,e){var t,n;t=[e,i,e(0)],void 0===(n=function(o,i,e){\"use strict\";let t;Object.defineProperty(i,\"__esModule\",{value:!0});const n=o=>i=>i<o?i:[...new Array(o)].map((e,t)=>n(o)(i-t-1)).reduce((o,i)=>o+i,0),r=n(3),c=n(4),d=e.robo({base:[0,1],recurrence:([o,i])=>o+i}),s=e.robo({base:[1],recurrence:([o],i)=>i*o}),u=o=>o.reduce((o,i)=>o+i,0),v=o=>e.robo({base:[...new Array(o)].map((o,i)=>i),recurrence:u}),a=v(3),f=v(4),B=e.robo({base:[0,1],next:[o=>o-2,o=>o-1],recurrence:([o,i])=>o+i}),b=e.robo({base:[0,1],next:[o=>o-1],recurrence:([o,i])=>o+i}),p=e.robo({base:[1],next:[o=>o-1],recurrence:([o],i)=>i*o}),l=e.robo({base:[1,0],recurrence:([o,i],e)=>(e-1)*(o+i)});e.robo({base:[1,0],next:[o=>o-1,o=>o-2],recurrence:([o,i],e)=>(e-1)*(o+i)});i.test=(()=>{(void 0)(\"single pass optimization works for\",function(){(void 0)(\"fibonacci\",function(){t(\"base cases\",function(){(void 0)(B(0)).toBe(0),(void 0)(B(1)).toBe(1)}),t(\"rest\",function(){(void 0)(B(2)).toBe(1),(void 0)(B(3)).toBe(2),(void 0)(B(4)).toBe(3),(void 0)(B(5)).toBe(5),(void 0)(B(6)).toBe(8)})}),(void 0)(\"implicit fibonacci\",function(){t(\"base cases\",function(){(void 0)(b(0)).toBe(0),(void 0)(b(1)).toBe(1)}),t(\"rest\",function(){(void 0)(b(2)).toBe(1),(void 0)(b(3)).toBe(2),(void 0)(b(4)).toBe(3),(void 0)(b(5)).toBe(5),(void 0)(b(6)).toBe(8)})}),(void 0)(\"super implicit fibonacci\",function(){t(\"base cases\",function(){(void 0)(d(0)).toBe(0),(void 0)(d(1)).toBe(1)}),t(\"rest\",function(){(void 0)(d(2)).toBe(1),(void 0)(d(3)).toBe(2),(void 0)(d(4)).toBe(3),(void 0)(d(5)).toBe(5),(void 0)(d(6)).toBe(8)})}),(void 0)(\"test tribonacci\",function(){t(\"base cases\",function(){(void 0)(a(0)).toBe(r(0)),(void 0)(a(1)).toBe(r(1))}),t(\"rest\",function(){(void 0)(a(2)).toBe(r(2)),(void 0)(a(3)).toBe(r(3)),(void 0)(a(4)).toBe(r(4)),(void 0)(a(5)).toBe(r(5)),(void 0)(a(6)).toBe(r(6))})}),(void 0)(\"test quadbonacci\",function(){t(\"base cases\",function(){(void 0)(f(0)).toBe(c(0)),(void 0)(f(1)).toBe(c(1))}),t(\"rest\",function(){(void 0)(f(2)).toBe(c(2)),(void 0)(f(3)).toBe(c(3)),(void 0)(f(4)).toBe(c(4)),(void 0)(f(5)).toBe(c(5)),(void 0)(f(6)).toBe(c(6))})}),(void 0)(\"factorial\",function(){t(\"base cases\",function(){(void 0)(s(0)).toBe(1)}),t(\"rest\",function(){(void 0)(s(1)).toBe(1),(void 0)(s(2)).toBe(2),(void 0)(s(3)).toBe(6),(void 0)(s(4)).toBe(24)})}),(void 0)(\"explicit factorial\",function(){t(\"base cases\",function(){(void 0)(p(0)).toBe(1)}),t(\"rest\",function(){(void 0)(p(1)).toBe(1),(void 0)(p(2)).toBe(2),(void 0)(p(3)).toBe(6),(void 0)(p(4)).toBe(24)})}),(void 0)(\"derangements\",function(){t(\"base cases\",function(){(void 0)(l(0)).toBe(1),(void 0)(l(1)).toBe(0)}),t(\"rest\",function(){(void 0)(l(2)).toBe(1),(void 0)(l(3)).toBe(2),(void 0)(l(4)).toBe(9),(void 0)(l(5)).toBe(44)})})}),(void 0)(\"single pass optimization with custom ordering works for\",function(){}),(void 0)(\"double pass optimization works for\",function(){}),(void 0)(\"double pass optimization with custom ordering works for\",function(){}),(void 0)(\"double pass time optimization works for\",function(){}),(void 0)(\"double pass time optimization with custom ordering works for\",function(){}),(void 0)(\"double pass space optimization works for\",function(){}),(void 0)(\"double pass space optimization with custom ordering works for\",function(){}),(void 0)(\"list recursion works for\",function(){}),(void 0)(\"list recursion with short circuiting works for\",function(){}),(void 0)(\"divide-and-conqceur works for\",function(){}),(void 0)(\"divide-and-conqceur implicit single-dimensional memoization works for\",function(){}),(void 0)(\"divide-and-conqceur explicit multi-dimensional memoization works for\",function(){})}),i.test()}.apply(i,t))||(o.exports=n)}]);","extractedComments":[]}